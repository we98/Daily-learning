## 第一章 简介
#### 1.1 并发简史
早期的操作系统不包含操作系统，它们从头到尾只执行一个程序，并且这个程序能访问所有资源，在这种裸机环境中难以编写和运行程序。操作系统的出现为每个独立执行的进程分配各种资源，同时不同的进程之间可以通过粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。操作系统的出现，主要基于以下原因：
- 资源利用率。在等待IO的同时运行另一个程序，大大提高了资源利用率。
- 公平性。不同的用户和程序对于计算机资源有着同等的使用权。可以通过粗粒度的时间分片做到资源共享，而不是一个程序运行完之后启动下一个。
- 便利性。使用多个程序完成多个计算任务，比使用一个程序完成所有程序更容易实现。
##### 线程的出现
这些促使进程出现的因素（资源利用率、公平性以及便利性等）同样也促使着进程的出现，线程具有以下特点：
- 线程允许一个进程中存在多个控制流，线程会共享进程范围内的资源，如内存句柄和文件句柄，但每个线程都有自己的程序计数器、栈以及局部变量等。
- 线程是基本的调度单位，因此一个程序中的多个线程可以同时调度到多个CPU上运行。
- 同一个进程内的所有线程都共享进程的地址空间，能访问进程内相同的变量，因此线程通信更加方便，但也需要一种比进程间共享数据粒度更细的数据共享机制。
#### 1.2 线程的优势
- 发挥多处理器的强大能力。
- 建模的简单性。将模型中每种类型的任务都分配一个专门的线程，可以形成一种串行执行的假象，使每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互。
- 异步事件的简化处理。如单线程服务器必须使用非阻塞IO才能保证响应性，但复杂性远远高于同步IO，如果为每个请求都使用线程，那么将简化服务器端的处理。
- 响应更灵敏的用户界面。
#### 1.3 线程带来的风险
- 安全性问题。在没有同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果。
- 活跃性问题。安全性关注“永远不发生糟糕的事情”，而活跃性则关注“某件正确的事情最终会发生”。常见的活跃性问题有：死锁、饥饿以及活锁。
- 性能问题。在设计良好的并发应用程序中，线程能够提升程序的性能。但无论如何，线程总会带来某种程度的运行时开销，如：
  - 线程调度导致频繁的上下文切换操作，将带来极大的开销。
  - 线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，使内存缓冲区的数据无效，以及增加共享内存总线的同步流量等。
#### 1.4 线程无处不在
虽然将并发性认为是一种“可选的”或者”高级的“语言功能固然理想，但现实情况是，几乎所有的Java应用程序都是多线程的。即使是使用某些封装好的多线程并发模块，如Timer、Servlet和远程方法调用等，也不可能将并发性仅局限于框架代码中，因为框架本身会回调应用程序的代码，这些代码将会访问应用程序的状态，因此，对线程安全性的需求将会在程序中蔓延开来。

