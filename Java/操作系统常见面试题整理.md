## 进程管理
#### 1、进程和线程的区别与联系。
- 相同点是进程和线程都可以认为是程序在CPU中的执行过程。
- 不同的是线程比进程粒度要小，进程是操作系统分配资源的基本单位，这些资源和进程所在的地址空间是进程私有和独占的，因此进程间的通信需要操作系统的协调才能完成。而线程是进程的执行控制流，是操作系统调度的基本单位，一个进程可以有多个线程，且这多个线程共享线程的内存地址和资源，所以同一进程内的线程通信比较容易做到，不需要操作系统的协调。
#### 2、进程通信的方式。
- 互斥量：在Java里面通过互斥锁实现
- 信号量：允许多个线程访问资源，但是有一个同时访问的最大数量，在java中也实现了
#### 3、进程通信的方式。
- 信号量：计数器，控制多个线程对资源的访问，通常作为一种锁机制。
- 信号：一种比较复杂的通信方式，用于通知进程某个事件已经发生。
- 消息队列：相当于消息的链表，内核维护。
- 共享内存：映射一段能被其他进程访问的内存，这个内存由一个进程创建，多个进程可以访问。
- 管道：半双工的通信方式，只能在具有亲缘关系的进程间流动，通常是父子进程。
- 命名管道：半双工，允许无亲缘关系的进程相互通信。
#### 4、进程间同步的几种方法。
- 进程间同步的主要方法有原子操作、信号量机制、自旋锁、管程、会合、分布式系统等。
#### 5、什么是死锁？死锁产生的条件？解决死锁的方法？
- 在多线程的情况下，占有资源的线程正在请求另一些资源，而另外一个线程也处于这样的状态，二者相互等待，程序无法向下运行，无限期阻塞，这就是死锁。
- 死锁产生的四个条件，四个必要条件，只要发生死锁，四个条件肯定满足：
  - 资源互斥，同一时间只能由一个进程得到。
  - 资源不可抢占，在进程未使用完资源自行释放时，该资源不能被抢占（被收回并交由其他进程，CPU，内存都是可抢占资源，而打印机是不可抢占资源）。
  - 请求与保持：已经占有了一个资源，但是请求另外的资源，并且同时不释放自己已经占有的资源。
  - 循环等待条件：即线程间互相请求资源构成了一个环。
- 处理死锁的方法：
  - 预防死锁：通过设置某些条件去破坏四个必要条件中的一个或多个，来防止死锁的发生
    - 破坏互斥条件：通常互斥条件是无法破坏的
    - 破坏“占有并等待”条件：
      - 一次性分配方案：要么把需要的资源全部分给线程，要么一个也不给。
      - 要求在每个线程在对新的资源提出申请之前，先释放自己占有的所有资源，即使它可能还需要使用自己已占有的资源。
    - 破坏“不可抢占”条件 ：
      - 如果占有某些资源的进程进一步请求其他资源的请求被拒绝，则该进程必须释放它已有的资源。
      - 如果一个进程请求被另一个进程占有的资源，则操作系统可以抢占另一个进程，要求另一个进程释放资源。只有在这两个线程优先级不同的情况下，该方法才有用。
    - 破坏“循环等待”条件
      - 将系统中所有资源统一编号，进程可以在任意时刻提出资源申请，但是所有申请必须按照资源的访问顺序（升序）提出，这样可以保证系统不出现死锁。
  - 避免死锁，与预防死锁的区别在于，预防死锁设法至少破坏一个必要条件，而避免死锁则没有那么严格，因为即使必要条件存在，也不一定发生死锁，常用的避免死锁的方法有：
    - 银行家算法。思想是：允许进程动态的申请资源，但是在系统分配给进程它想要的某些资源前，会先进行计算，判断是否分配后会使系统进入到一个不安全的状态，如果会，则等待，如果不会，则分配。
    - 银行家算法大致流程为：当前系统有一个available数组，里面记录着各类资源的数量，每个进程有一个need数组，代表当前还需要各类资源的数量，有一个allocation数组，代表已经得到的资源数量。设置一个work数组起始等于available，跟当前的几个进程依次比较work和need，如果need<=work，则代表当前进程可以直接完成它的工作，则设置finish[i]=true，且work+=allocation。如果need>work，则跳过，先进行下一个进程的比较。如果最后，所有的finish都是true，则代表存在一个序列，比如{p0, p2, p4, p3}按照这个的工作顺序是合理的，那么系统就是安全的，如果不存在，则系统是不安全的。
  - 检测死锁
  - 解除死锁
#### 6、线程的几种状态以及发生状态转换的情况。
- 新建、就绪、运行、阻塞、终止
- 就绪、运行、阻塞的转换条件
  - 就绪->执行，当前线程时间片结束或者阻塞，CPU选出就绪队列中优先级最高的进程运行
  - 执行->就绪，时间片结束
  - 执行->阻塞，等待键盘输入和其他IO等
  - 阻塞->就素，IO操作完成，被中断处理程序唤醒
#### 7、操作系统的进程调度策略
- 先来先服务（时间优先），FCFS，每次调度从就绪队列里选择一个最先进入队列的进程，选中的进程一直运行到进程结束或者发生某件事而阻塞后才放弃CPU。
- 短作业优先，SJF，从就绪队列中选择一个估计运行时间最短的进程，选中的进程一直运行到进程结束或者发生某件事而阻塞后才放弃CPU。
- 高优先权优先调度算法，分为两个：
  - 非抢占式优先权算法，CPU选择一个优先权最高的进程执行，直至执行结束或阻塞。
  - 抢占式优先权算法，CPU选择一个优先权最高的进程执行，但是如果在未执行完又来了一个优先级更高的线程，则CPU被抢占，主要用于比较严格的实时系统中。
- 基于时间片的轮转调度算法：
  - 时间片轮转法，每次调度时，将CPU分配给队首进程，并分配时间片，当时间片执行完时，将该进程放置队列尾。
  - 多级反馈队列调度算法
    - 有多个就绪队列，每个就绪队列优先级不同，0队列优先级最高，之后的队列优先级逐渐下降，且优先级越低，该队列的时间片越多。
    - 新来的进程加入到0队列的队尾，如果在一个时间片内没有完成，它将被添加到1队列的队尾，如果完成，则直接离开。
    - 只有当0队列为空时，才会运行1队列。
    - 如果正在运行1队列时，0队列加入了新进程，则1队列中的进程将被抢占。
    - 该算法对运行时间短的进程很有利。
## 内存管理
#### 1、什么是缓冲区溢出？有什么危害？其原因是什么？
- 是指向缓冲区填充的数据超过了缓冲区的容量，然后溢出的数据覆盖了其他合法的数据。
- 危害：程序崩溃、或者覆盖返回地址使其跳转到恶意代码。
- 原因是因为程序没有仔细检查用户输入。
#### 2、分段和分页。
- 分段解决的是虚拟空间到物理空间映射的问题。
- 分页在分段的基础上解决了内存利用率低的问题。
- [https://www.zhihu.com/question/50796850/answer/522734117](https://www.zhihu.com/question/50796850/answer/522734117)

