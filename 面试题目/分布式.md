## 分布式
#### 1、分布式锁

- 在单进程多线程的条件下，当很多线程访问统一接口时，而该接口如果操作了共享对象，则需要使用Java的内置锁进行同步，可以保证线程安全。但是如果在多进程条件下，该锁只是在进程内部的，也就是每一个进程都有一把这样的锁，这样是无法保证线程安全的。因此，需要一种第三方媒介来作为任何一个机器上任何一个进程都能看到的一把锁，这样便可以保证线程安全。![1565405544531](pictures\为什么要有分布式锁.png)

- 因此，在设计这个第三方媒介作为分布式锁时，要注意以下几个问题：
  - 这个锁是公平锁还是非公平锁
  - 排他锁还是共享锁
  - 是否可重入
  - 阻塞还是非阻塞锁（当一个线程抢不到这把锁时，该线程的状态）
- 因此，根据这几个设计思想，为了实现排他性，可以选用以下几种方式来实现分布式锁：![1565408480561](pictures\分布式锁的可选技术.png)
  - 文件系统，同一目录下不可能有两个的文件名，可以实现排他性
  - 数据库
  - redis
  - Zookeeper
- 以下是这几个不同技术选型的优缺点![1565408683118](pictures\不同分布式锁实现的优缺点.png)
  - 对于数据库和文件系统而言，都没有失效时间，因此容易导致死锁和单点故障问题，性能较差
    - 使用文件系统实现分布式锁的方法：比如有这样的约定，在目录/下创建lock.txt文件成功即为获取成功对应的锁，获取成功后，便可以去执行共享代码块。对于没有获取成功的线程而言，**该线程不能直接简单的阻塞**，因为阻塞了之后，在多个分布式进程之间是没有所谓的通知唤醒的，因此没有获取成功的线程应该做类似轮询的工作，一直检测该文件是否存在。但是，**如果当获得锁的线程意外终止，并没有及时地释放这把锁，则会导致死锁问题。**
    - 如何解决这种死锁问题？一种方法是，在存储这把锁的机器内开启一个守护线程，当发现超时机制时，将该文件删除。那么仍然存在问题，如果获取锁的线程只是花了很长时间来做业务，并没有意外终止而超时，如何解决？目前的解决方案就是评估业务所需要的时间，根据不同的业务给予不同的超时时间
    - 数据库实现的方式与文件系统类似，只不过约定有所改变而已，如文件系统是临时创建文件代表抢锁。数据库的实现方式则是在一个唯一性的表中插入数据代表抢锁
  - redis可能出现短时间死锁的可能
    - 对redis而言，本身就可以做到超时检测，不需要手动部署守护线程。因此，使用redis时，要像上文提到的那样，根据不同的业务的锁设置不同的超时时间
  - Zookeeper，也用来解决分布式锁的问题，在上文提到的死锁问题，以及没有得到锁的线程需要轮询这种不优雅的方式都得到了解决。Zookeeper的特性之一是可以创建临时节点，当与之相连的客户端断开连接的时候，该临时节点就会被自动地清除。实质上，这是Zookeeper的心跳检测机制，client通过心跳机制与服务端保持一个长连接，一旦client断开，服务端就会将这个client创建的临时节点给删除。通过这样的机制，不需要为每个业务设置超时时间，也不会出现死锁问题。