## 进程管理
#### 1、进程和线程的区别与联系。
- 相同点是进程和线程都可以认为是程序在CPU中的执行过程。
- 不同的是线程比进程粒度要小，进程是操作系统分配资源的基本单位，这些资源和进程所在的地址空间是进程私有和独占的，因此进程间的通信需要操作系统的协调才能完成。而线程是进程的执行控制流，是操作系统调度的基本单位，一个进程可以有多个线程，且这多个线程共享线程的内存地址和资源，所以同一进程内的线程通信比较容易做到，不需要操作系统的协调。
#### 2、进程通信的方式。
- 互斥量：在Java里面通过互斥锁实现
- 信号量：允许多个线程访问资源，但是有一个同时访问的最大数量，在java中也实现了
#### 3、进程通信的方式。
- 信号量：计数器，控制多个线程对资源的访问，通常作为一种锁机制。
- 信号：一种比较复杂的通信方式，用于通知进程某个事件已经发生。
- 消息队列：相当于消息的链表，内核维护。
- 共享内存：映射一段能被其他进程访问的内存，这个内存由一个进程创建，多个进程可以访问。
- 管道：半双工的通信方式，只能在具有亲缘关系的进程间流动，通常是父子进程。
- 命名管道：半双工，允许无亲缘关系的进程相互通信。
#### 4、进程间同步的几种方法。
- 进程间同步的主要方法有原子操作、信号量机制、自旋锁、管程、会合、分布式系统等。
#### 5、什么是死锁？死锁产生的条件？解决死锁的方法？
- 在多线程的情况下，占有资源的线程正在请求另一些资源，而另外一个线程也处于这样的状态，二者相互等待，程序无法向下运行，无限期阻塞，这就是死锁。
- 死锁产生的四个条件，四个必要条件，只要发生死锁，四个条件肯定满足：
  - 资源互斥，同一时间只能由一个进程得到。
  - 资源不可抢占，在进程未使用完资源自行释放时，该资源不能被抢占（被收回并交由其他进程，CPU，内存都是可抢占资源，而打印机是不可抢占资源）。
  - 请求与保持：已经占有了一个资源，但是请求另外的资源，并且同时不释放自己已经占有的资源。
  - 循环等待条件：即线程间互相请求资源构成了一个环。
- 处理死锁的方法：
  - 预防死锁：通过设置某些条件去破坏四个必要条件中的一个或多个，来防止死锁的发生
    - 破坏互斥条件：通常互斥条件是无法破坏的
    - 破坏“占有并等待”条件：
      - 一次性分配方案：要么把需要的资源全部分给线程，要么一个也不给。
      - 要求在每个线程在对新的资源提出申请之前，先释放自己占有的所有资源，即使它可能还需要使用自己已占有的资源。
    - 破坏“不可抢占”条件 ：
      - 如果占有某些资源的进程进一步请求其他资源的请求被拒绝，则该进程必须释放它已有的资源。
      - 如果一个进程请求被另一个进程占有的资源，则操作系统可以抢占另一个进程，要求另一个进程释放资源。只有在这两个线程优先级不同的情况下，该方法才有用。
    - 破坏“循环等待”条件
      - 将系统中所有资源统一编号，进程可以在任意时刻提出资源申请，但是所有申请必须按照资源的访问顺序（升序）提出，这样可以保证系统不出现死锁。
  - 避免死锁，与预防死锁的区别在于，预防死锁设法至少破坏一个必要条件，而避免死锁则没有那么严格，因为即使必要条件存在，也不一定发生死锁，常用的避免死锁的方法有：
    - 银行家算法。思想是：允许进程动态的申请资源，但是在系统分配给进程它想要的某些资源前，会先进行计算，判断是否分配后会使系统进入到一个不安全的状态，如果会，则等待，如果不会，则分配。
    - 银行家算法大致流程为：当前系统有一个available数组，里面记录着各类资源的数量，每个进程有一个need数组，代表当前还需要各类资源的数量，有一个allocation数组，代表已经得到的资源数量。设置一个work数组起始等于available，跟当前的几个进程依次比较work和need，如果need<=work，则代表当前进程可以直接完成它的工作，则设置finish[i]=true，且work+=allocation。如果need>work，则跳过，先进行下一个进程的比较。如果最后，所有的finish都是true，则代表存在一个序列，比如{p0, p2, p4, p3}按照这个的工作顺序是合理的，那么系统就是安全的，如果不存在，则系统是不安全的。
  - 检测死锁
  - 解除死锁
#### 6、线程的几种状态以及发生状态转换的情况。
- 新建、就绪、运行、阻塞、终止
- 就绪、运行、阻塞的转换条件
  - 就绪->执行，当前线程时间片结束或者阻塞，CPU选出就绪队列中优先级最高的进程运行
  - 执行->就绪，时间片结束
  - 执行->阻塞，等待键盘输入和其他IO等
  - 阻塞->就素，IO操作完成，被中断处理程序唤醒
#### 7、操作系统的进程调度策略
- 先来先服务（时间优先），FCFS，每次调度从就绪队列里选择一个最先进入队列的进程，选中的进程一直运行到进程结束或者发生某件事而阻塞后才放弃CPU。
- 短作业优先，SJF，从就绪队列中选择一个估计运行时间最短的进程，选中的进程一直运行到进程结束或者发生某件事而阻塞后才放弃CPU。
- 高优先权优先调度算法，分为两个：
  - 非抢占式优先权算法，CPU选择一个优先权最高的进程执行，直至执行结束或阻塞。
  - 抢占式优先权算法，CPU选择一个优先权最高的进程执行，但是如果在未执行完又来了一个优先级更高的线程，则CPU被抢占，主要用于比较严格的实时系统中。
- 基于时间片的轮转调度算法：
  - 时间片轮转法，每次调度时，将CPU分配给队首进程，并分配时间片，当时间片执行完时，将该进程放置队列尾。
  - 多级反馈队列调度算法
    - 有多个就绪队列，每个就绪队列优先级不同，0队列优先级最高，之后的队列优先级逐渐下降，且优先级越低，该队列的时间片越多。
    - 新来的进程加入到0队列的队尾，如果在一个时间片内没有完成，它将被添加到1队列的队尾，如果完成，则直接离开。
    - 只有当0队列为空时，才会运行1队列。
    - 如果正在运行1队列时，0队列加入了新进程，则1队列中的进程将被抢占。
    - 该算法对运行时间短的进程很有利。
## Unix相关
#### 1、五种IO模型
- 同步阻塞：线程会一直阻塞，直至数据准备完成，在数据准备完成后，从内核空间拷贝到用户空间，然后函数返回（几种同步阻塞的socket api如下）
  - 输入操作：recv()，recvfrom()，以阻塞套接字为参数接收数据，如果套接字中无数据，则线程在数据到来之前一直等待
  - 输出操作：send()，sendto()，以阻塞套接字为参数发送数据，如果套接字缓冲区已满，则线程等待，直至有空间
  - 接受连接：accept()，以阻塞套接字为参数接受对方的连接请求，如果无连接请求，线程等待
  - 发起连接：connect()，对于TCP连接，客户端以阻塞套接字为参数，在收到服务器应答前，线程等待，这意味着这个函数至少要等待从客户端到服务器的一次往返时间
  - 总结：使用阻塞模式的套接字，开发网络程序比较简单，容易实现，当希望能够立即发送和接收数据，且处理的套接字数量比较少的情况下，使用阻塞模式比较合适。不足表现为，在大量建立好的套接字线程之间进行通信比较困难
- 同步非阻塞：在数据准备阶段，所请求的IO操作无法完成时，函数会返回一个错误标识，此时线程不会等待，而是继续发起相同的IO操作请求，直至函数返回成功指示，此时应用程序开始处理数据
  - 对于recv()函数来说，当这个函数以非阻塞套接字为参数接收数据时，在数据没有准备好之前，返回错误标识，而不是将线程等待。因此在实现非阻塞IO时，应在循环中持续发起recv()系统调用，当函数返回正确指示时，说明数据已经准备完成并且被复制到了用户空间中，此时跳出循环处理数据即可
  - 非阻塞模式与阻塞模式相比，不容易使用，需要编写更多的代码。但是在多个连接，数据收发量不均，时间不定时，具有明显的优势
- IO多路复用
- 信号驱动IO：两次调用，两次返回。首先允许套接字进行信号驱动IO，并安装一个信号处理函数，之后函数返回线程继续向下运行（不需要轮询）。当数据准备好时，会收到一个SIGIO信号，然后在信号处理函数中处理数据
- 异步IO：上述四种同步IO，都是在数据准备完成阶段之后，数据转移过程中线程是阻塞的，但是在异步IO过程中，调用者发起请求后立即返回，数据转移的过程完成后，通过类似通知的机制来通知调用者任务已经完成
#### 2、多路复用IO的几种实现方式
select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。  
- select，说的通俗一点就是各个客户端连接的文件描述符也就是套接字，都被放到了一个集合中，调用select后会轮询监视这些文件描述符中有哪些可读，如果有可读的socket，那么工作进程就去读取资源。但是这个集合的数目是有限的，32位机默认是1024，64位机默认是2048
  - select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长
- poll， 本质上跟select没有区别，但是它没有最大连接数的限制，原因就是它是基于链表来存储的
- epoll，当套接字较多时，每次select都要遍历FD_SETSIZE个socket来完成调度，不管哪个socket是活跃的，都遍历一遍，这会浪费很多CPU时间。如果能给某个套接字注册某个回调函数，当它们活跃时，自动完成相关操作，这就避免了轮询，复杂度降到了O(1)
  - 优点
    - 没有最大并发连接的限制，能打开的FD远大于1024，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接
    - 效率提升，不是轮询的方式，不会随着FD数量的增加而效率下降，因为只有活跃的FD才会调用callback函数，它只管“活跃”的连接，与连接总数无关，因此在实际的网络环境下，epoll要比select和poll效率高

参考链接：[https://www.cnblogs.com/aspirant/p/9166944.html](https://www.cnblogs.com/aspirant/p/9166944.html)
#### 3、Java中nio基于epoll
参考链接：
[https://blog.csdn.net/u011381576/article/details/79876754](https://blog.csdn.net/u011381576/article/details/79876754)
[https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247483907&idx=1&sn=3d5e1384a36bd59f5fd14135067af1c2&chksm=fb0be897cc7c61815a6a1c3181f3ba3507b199fd7a8c9025e9d8f67b5e9783bc0f0fe1c73903&scene=21#wechat_redirect](https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247483907&idx=1&sn=3d5e1384a36bd59f5fd14135067af1c2&chksm=fb0be897cc7c61815a6a1c3181f3ba3507b199fd7a8c9025e9d8f67b5e9783bc0f0fe1c73903&scene=21#wechat_redirect)
[https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247483913&idx=1&sn=2da53737b8e8908cf3efdae9621c9698&chksm=fb0be89dcc7c618b0d5a1ba8ac654295454cfc2fa81fbae5a6de49bf0a91a305ca707e9864fc&scene=21#wechat_redirect](https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247483913&idx=1&sn=2da53737b8e8908cf3efdae9621c9698&chksm=fb0be89dcc7c618b0d5a1ba8ac654295454cfc2fa81fbae5a6de49bf0a91a305ca707e9864fc&scene=21#wechat_redirect)
## 内存管理
#### 1、什么是缓冲区溢出？有什么危害？其原因是什么？
- 是指向缓冲区填充的数据超过了缓冲区的容量，然后溢出的数据覆盖了其他合法的数据。
- 危害：程序崩溃、或者覆盖返回地址使其跳转到恶意代码。
- 原因是因为程序没有仔细检查用户输入。
#### 2、分段和分页。
- 分段解决的是虚拟空间到物理空间映射的问题。
- 分页在分段的基础上解决了内存利用率低的问题。
- [https://www.zhihu.com/question/50796850/answer/522734117](https://www.zhihu.com/question/50796850/answer/522734117)

