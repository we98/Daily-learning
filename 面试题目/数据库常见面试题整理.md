## 数据库事务
#### 1、事务的四大属性
#### 2、并发一致性问题
- 更新丢失（修改丢失）
  - T1和T2同时对同一个数据进行修改，T2后修改，T2的修改覆盖了T1的修改（可以用两次转账请求，一次50，一次100来类比）
  - 解决方案：在一个事务提交之前，另一个事务不能访问相同的数据
- 脏读
  - 事务T2读到了事务T1已修改但是未提交的数据，还在这个数据的基础上做了操作，如果T1回滚，则此数据无效，不符合一致性要求
  - 解决方案：把数据库隔离级别调整为READ_COMMITTED
- 不可重复读
  - 事务T2多次读取同一个数据，在事务没有结束之前，T1修改了这个数据，导致两次数据读取不一致（一个事务范围内两个相同的查询却返回了不同的数据）
  - 解决方案：只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。把数据库隔离级别调整到REPEATABLE_READ
- 幻读
  - 事务T2按照相同的查询条件重新读取以前检索过的数据，却发现其他事务T1插入了满足其查询条件的新数据，这种现象称为幻读（和可重复读类似，但是T1的操作是插入和删除，不是修改数据，导致前后读取的数量不一致）（一句话，事务读取到了另一个事务的新增数据，不符合隔离性）
  - 解决方案：在操作事务完成数据处理之前，其他任何事务不能添加新数据，则可以避免该问题。把数据库的隔离级别调整到SERIALIZABLE_READ
#### 3、事务隔离级别
> 脏读、不可重复读、幻读，其实都是数据库读一致性问题，必须由数据库提供一定的隔离机制来解决
> 数据库事务隔离越严格，并发引起的一致性问题越少，但付出的代价也越大（串行化增大），因为事务隔离实质上就是使事务在一定程度上“串行执行”

- 读未提交
  - 最低的隔离级别，允许其他事务看到没有提交的数据，会导致脏读
- 读已提交
  - 可以解决脏读问题，但是被读取的数据可能被其他事务修改，这样导致了不可重复读
  - 实质上是，在事务读取的时候获取读锁，在读完之后立即释放（不需要等待事务结束），而写锁则是事务提交之后才释放，在释放读锁之后，就可能被其他事务修改数据
  - READ_COMMITTED，这是SQL Sever的默认隔离等级
- 可重复读
  - 所有Select获取的数据都不能被修改，这样就可以避免一个事务内前后数据读取不一致问题
  - 该事务获得读锁，因此可以解决保证可重复读问题
  - 但是不能解决幻读问题，因为事务有读锁但没有范围锁，其他事务不能修改该数据，但可以插入新数据
  - REPEATABLE_READ，这是MYSQL的默认隔离等级
- 串行化
  - 完全解决了问题，对于基于锁来实现并发控制的数据库来说，要求事务获得范围锁，但是所有事务被串行化
  - 如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需要回滚该事务（类似CAS？）
隔离级别 | 读数据一致性 |  脏读 | 不可重复读 | 幻读  
-|-|- | - | - |
读未提交 | 最低级别 |  |  |  |
读已提交 | 语句级 | 解决 |  |  |
可重复读 | 事务级 | 解决 | 解决 |  |
串行化 | 最高级别，事务级 | 解决 | 解决 | 解决 |
## MySQL MVCC

多版本并发控制，可以认为是乐观锁的一种实现方式，是通过保存数据在某个时间点的快照来实现的，也就是说，无论一个事务运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。

##### Innodb如何实现mvcc

在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。

每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。

InnoDB会根据以下两个条件检查每行记录: 
a.InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的. 
b.行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除. 

<https://blog.csdn.net/whoamiyang/article/details/51901888>

<https://blog.csdn.net/chen77716/article/details/6742128>

## MySQL锁

<https://blog.csdn.net/soonfly/article/details/70238902>

## MySQL存储引擎
MySQL存储引擎用于规定表的存储方式，因此存储引擎针对的对象是具体的表，而不是整个数据库，主要包括MyISAM和Innodb
- MyISAM
  - 索引和数据时分开存储的，针对每一张表，.frm文件是存储表结构，.MYD.文件用于存储数据，.MYI用于存储索引
  - 支持表级锁（表级锁不会引发死锁，因为使用了预防死锁的方法，打破了占有并请求这一必要条件，在进行操作之前，会一下获得所有相关的表，并且在锁定期间，不可再请求其他表）
- Innodb
  - 索引和数据一起存储，.frm用于存储表结构，.ibd用于存储索引+数据
  - 支持事务，支持表级锁、行锁
  - 主键索引使用聚集索引，叶子节点的数据是每行记录，非主键索引使用的是非聚集索引，叶子节点的数据时当前索引对应的主键值
  
  > 聚集索引和非聚集索引在查询数据时有何区别？
  >
  > 一般情况下，使用聚集索引能直接得到当前行的数据，而使用非聚集索引只能查到当前索引对应的主键值，因此需要回表重新进行一次查询。
  >
  > 但是所有的非聚集索引都需要回表查询吗？
  >
  > 不一定，通过覆盖索引也可以只查询一次。覆盖索引——是指一个查询语句需要的结果从索引本身就可以获得，不必从数据表中读取。当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引本身就可以获得查询所需要的数据，因此无需回表。例如，加入有一个联合索引(key1, key2)，那么查询语句select key2 from table_name where key1="111"，这种情况下无需回表。
## MySQL索引
索引是帮助MySQL高效获取数据的排好序的数据结构，存储在文件里，通过一定的数据结构将索引列的所有数据组织起来使其有序，便可以快速定位到当前数据记录，达到优化慢查询的目的。下面从几种不同的维度讲解MySQL索引的本质以及分类：
#### 1、从数据结构来分，MySQL索引可以通过B+树或hash表来组织
![1564973437265](pictures\B树.png)
![1564974122337](pictures\B+树.png)
![1564976316177](pictures\B+树性能分析.png)
![1564976384862](pictures\B+树性能分析2.png)

##### 1.1、B树和B+树
- B树，结构如上图，B树是传统二叉树的改良版，原来的二叉树的度为2，而B树可以很大程度的增加度的数量，因此可以有效的降低树的高度。同时，在每一个节点上根据索引列的具体值同时存储了对应的data（data可以是当前记录的磁盘地址指针，也可以是当前的记录行，这跟具体的存储引擎有关），跟原二叉树的结构十分类似。但是由于存储data也需要占用空间，当data很大时，会急剧压缩度的数量（因为索引节点的大小是限定的，MySQL中默认为16k），因此就出现了下面的B+树
- B+树，如上图所示，为了增加度的数量，B+树在B树的基础上去掉了非叶子节点的data，如此可以增加度的大小，但是因为去掉了对应的data，所以在B+树不同的节点之上会有冗余的索引列的值，且所有的data存储在叶子节点上，如此便构成了B+树的基本结构
  - 下面以一个具体例子来说明一下2~4层的B+树可以存储的数量。假设一个节点给定的大小是16k（MySQL默认值），假设在非叶子节点中，索引列的类型是bigint（8字节），而磁盘地址在MySQL中实现为6字节，那么每个非叶子节点的度为1024\*16/14=1170，那么在三层B+树的情况下，对于第一层和第二层非叶子节点来说，结构符合上述的情况。对于第三层叶子节点来说，结构稍有不同，叶子节点中存的是索引值+data的列表，假设一个索引值+data的大小为1k，那么一个叶子节点可以存16项记录，则三层B+树最大存储的记录数量为1170\*1170\*16=2千万，如此，便实现了3层B+树完成了千万级别的数据量索引的组织
  - 同时，可以注意到，B+树相比于B树叶子节点上多了指向前后元素的双向指针（图上有误，链表应为双向），这是为什么呢？参见下文B+树与hash表的对比，解决了范围查找的问题
> 为什么不用红黑树？当数据量为百万或千万级别的时候，红黑树仍然需要几十层，此时磁盘IO次数仍然很多，完全做不到像B+树这样2~4层就可以存储千万级别的索引记录
##### 1.2、hash表
- 使用hash散列算法将数据存到hash表中
##### 1.3、二者对比
在使用精确匹配查找的时候，hash表是很快，如
```sql
select * from t
where t_id = 5;
```
但是，在使用范围查找的时候，如果当前索引是hash表结构，则查找不会走索引（全表搜索），因为hash在比较相等时性能很优越，但是在范围查找时，hash无能为力，如下：
```sql
select * from t
where t_id > 5;
```
但为什么B+树有这个能力呢？原因就是B+树的叶子节点中存储着指向前后叶子节点的指针，当找到相应索引值时，便可以通过这个指针前向或后向遍历，完成范围查找
所以，在绝大多数情况下，B+树会作为首选

#### 2、从存储引擎方面来看，MySQL索引可以分为聚集索引和非聚集索引
![1564976481200](pictures\非聚集索引.png)
![1564976542999](pictures\聚集索引.png)
##### 2.1、非聚集索引
- 叶子节点中的data存储当前记录行对应的磁盘文件指针
##### 2.2、聚集索引
- 叶子节点中的data存储当前记录除了索引的其他字段值
##### 2.3、一些面试题，理解了MySQL索引底层结构之后便很容易理解
- 为什么Innodb必须有主键，并且推荐使用整形自增主键
  - 即使没有显式的建立主键，Innodb也会增加一列作为主键。因为MySQL采用索引+数据的存储方式（聚集索引），因此必须要有一个主键索引来作为B+树的参考值对表的数据进行组织和存储，这就是必须由主键的原因
  - 为什么要整形？因为B+树组织数据的时候是需要进行比较的，而整形数据的比较效率要高于字符串的比较效率。同时，假设使用uuid来作为主键，其占用空间也比整形数据要多
  - 为什么自增？对于索引值来说，当使用自增主键时，新插入的索引值会在叶子节点的最后面插入，因为叶子节点默认从左到右就是递增顺序。但是如果使用uuid作为主键时，新插入的索引值不一定能保证按照递增的顺序插入，当出现插入非递增索引值时，可能会导致已有的叶子节点所在的页断裂，当分裂之后再进行平衡会导致性能下降。参考链接：[https://www.jianshu.com/p/1203fd140cc2](https://www.jianshu.com/p/1203fd140cc2)
- 为什么Innodb非主键索引结构叶子节点存储的是主键值
  - 在MyISAM中，所有索引叶子节点里面的值都是当前记录的外存地址，而在Innodb中不一样，主键索引的值就是当前记录的所有字段，但是其他非主键索引也要有data，为了保证数据一致性和减少存储量，非主键索引中的data是当前记录的主键值
#### 3、从索引的字段数量来说，MySQL可以分为单值索引和联合索引
![1564985509320](pictures\联合索引.png)
- 单值索引

- 联合索引，在实际应用中用的是最多的，原理是在比较中按照顺序进行字段的比较，当第一个字段相等时比第二个，以此类推

  > 联合索引的最左匹配前缀原则，如果建立一个(a, b, c)的联合索引，那么什么语句会走这个索引呢？
  >
  > 答案是where a = 1 where a = 1 and b = 1 where a = 1 and b = 1 and c = 1。事实上where a = 1 and c = 1这种方案不会走(a, b, c)索引，只会走a字段索引，然后根据查出来的视图全表扫描。where a = 1 and b > 1 and c = 1也不会走(a, b, c)索引，只会走(a, b)索引，因为当选出来a = 1 and b > 1之后，c就已经无序了，所以在选出来的视图上根据c = 1进行全表扫描。
#### 4、使用和构建索引的注意事项

- 一个表的索引不要创建太多
- 数据量小的，使用不频繁的不要建立索引
- 对数据更新频繁的表，也不要建立太多索引，因为维护数据的同时也要维护索引本身
- 用于索引的列应该最好是出现在where字句，join字句，order by字句或group by字句的列中

#### 5、什么情况下发生明明通过索引列进行查询，但执行的时候却没有通过索引呢

> 这个问题跟查询优化器有关。
>
> 对于一条查询语句，MySQL的查询优化器会找出执行该语句的所有可能使用的方案，对比出估计成本最低的方案，这个成本最低的方案就是所谓的执行计划。优化过程大致如下： 1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个
>
> 因此针对于select * from table_name where a <> 1，这种情况不走索引，因为要选出来绝大部分数据，全表扫描要比走索引快！

## 数据库架构
#### 1、数据库分库分表相关问题
- 分库分表的意义
  - 提高查询速度（主要是分表）
  - 减轻数据库压力（高并发）：一个数据库支持的连接数是有限的，如果所有请求都面向同一个节点的数据库，则压力很大，如果有多个节点同时分担，则压力小很多
  - 提升存储的容量（主要针对于分库）：一个物理机器能支持的数据容量始终是有限的，因此多个节点上的分库可以支持更大的数据量
- 多少数据量需要分库分表
  > 单表行数超过500万行或者单表容量超过2G，才推荐进行分库分表（如果预计三年后的数量根本达不到这个级别，请不要在创建时就使用分库分表，这样会带来十分大的复杂度）——引用自阿里巴巴规范
  
  - 事实上，如果数据库字段不是很多，数据库索引设计的也比较合理，一张表存5000万行数据是没什么问题的，不过实际情况还是要看具体的测试情况
- 分库分表到底怎么拆分
  - 垂直切分，依靠表字段来切分，切分出来的结果是两张不同的表
    - 垂直分库，按照不同模块的功能划分为多个数据库，可能会带来以下问题：
      - 跨库的关联查询join（应通过合理的业务划分将此类需求降到最少），解决方案：
        - 字段冗余
        - 数据同步，比如商户查询产品表时，可以在商户数据库中添加产品表，使用完之后，再同步到产品表数据库中
        - 广播表（全局表），对于所有数据库中都需要使用到的表，这个表通常数据量不是很大且不发生改变，可以在每个数据库中都放置一份，比如基础配置，可以做成广播表
        - 绑定表，如订单表和订单明细表，将最重要的信息拆分出来，同时使用订单id来做概念上的外键，而不是真正的建立实际的外键关系，这是一种很常见的设计方式
      - 分布式事务，在单库中使用Innodb提供的事务管理可以很好的解决数据一致性问题，而多个节点的数据库不容易处理好这个问题
        - 使用分布式事务中间件来解决这个问题，如Atomikos，LCN，GTS等，不同的中间件也遵循着相同的基础理论
  - 水平切分，依靠数据来切分，切分出来的表结构相同，但不同的表存不同的数据
    - 水平分库分表，在垂直分库后，单个功能模块对应的单个库中表的容量已经非常大了，物理硬件已经无法提供很好的支持，这时仍然需要再次水平分库，每个数据库中表结构是一样的，但是存储的数据时不一样的，下面是水平分库分表可能遇到的问题：
      - 跨库的关联查询，和垂直分库类似
      - 翻页，如果查询一系列数据，这一系列数据分布在不同的数据库中，那么如何将符合条件的所有数据取出呢
      - 全局ID问题，比如如果设置自增主键，怎样保证不同的表中主键不重复
      - 拆分规则，如何保证良好的扩容缩容机制，如何均匀，如何保证更好的查询效率（sharding-jdbc可以用来解决这个问题）
        - hash取模：比较均匀，但是当扩容缩容的时候是否要对所有的数据进行重新hash呢？解决这个问题的方法叫做一致性hash（详见下文）
        - 范围：比如1-500w放在数据库1,500w-1000w放在数据库2
        - 枚举：比如根据性别，男的在一个数据库，女的在一个数据库
        - 复合算法：可以先取模再哈希之类的
#### 2、一致性哈希
#### 3、数据库分库分表解决方案——sharding-jdbc
以下展示出了sharding-jdbc的几个重要概念：
![1564919770833](pictures\shardingjdbc核心概念一.png)
- 逻辑表：用户看到的表并可以直接操作的表，完全可以当作一张表，但是实际不存在，由sharding-jdbc进行转换
- 真实表/数据节点：真正存储在不同物理机器上的数据库上的表，对用户透明
- 分片键：当根据user_id取模进行水平切分时，user_id就是分片键，使用日期分片时，则日期是分片键
- 分片算法：即上文说到的拆分规则

![1564920166429](pictures\shardingjdbc核心概念二.png)
- 动态表：表名会动态变化的表

![1564920292572](pictures\shardingjdbc核心概念三.png)
- 广播表：就是上文提到的一种表，将这种读多写少并且数据量不是很大的表（如配置表）在每个数据库中放置一份，可以尽量避免跨库查询（但是当要修改时，则要在每个库中都修改）

![1564920581389](pictures\shardingjdbc核心概念四.png)
- 绑定表：如上文提到，也是一种解决跨库访问的方式


