## 数据结构常见问题
#### 1、几种常见的hash函数
- 除留余数法
  - h(key) = key mod M，其中M是散列表的大小，选择不超过M的素数P，另函数为h(key) = key mod P，会收到比较好的效果
- 平方取中法
  - 首先将key平方，然后取key平方的中间部分作为散列值，中间部分的长度取决于M的大小
  - 假设计算机字长W位，M是散列表长，且当取k时，是的2^k恰好小于等于M，则先对key平方，得到一个W位的值，再将这个值无符号右移W-k位，获得一个0-M-1之前的数字
- 折叠法
  - 假设key = 123 203 241 112 20，且散列地址取三位，则将key划分为5段
  - 移位法：计算123 + 203 + 241 + 112 + 20 = 699，高位舍弃
  - 分界法：计算123 + 302 + 241 + 211 + 20 = 897，高位舍弃
#### 2、解决hash冲突的几种方式
- 开放定址法，和拉链法不同，数据元素都是存到表中的，插入关键字值为key的新元素的方法是：从h(key)开始，依次按照某种规定的次序在表中探查允许插入新元素的空位置，此时地址h(key)被称为基位置，此时探查序列形如：h(key) (h(key) + p(1)) mod M, ......, (h(key) + p(i)) mod M, ......，当发现当前探查位置已经被占据，则探查下一个位置，如果未被占用，则当前元素将其占用
  - 探查序列有以下几个规则/方式：
    - 线性探查法，直接查找下一个元素，当查找到M-1时，另索引为0，从头开始查找，直至h(key)，说明hash表已满
    - 二次探查法，线性探查法有一个缺点，它容易使得许多元素在散列表中连成一片，降低搜索效率，这种现象称为基本聚集。为了解决基本聚集问题，二次探查法提出的策略是h(key)  h(key)+1^2  h(key)-1^2  h(key)+2^2  h(key)-2^2  ......  h(key)+i^2  h(key)-i^2  ......  这样可以消除基本聚集
    - 双散列法，由于对于同一个元素有着相同的探查序列，二次探查法会产生一个问题叫做二级聚集问题。为了解决这个问题，提出了双散列法。思想是准备两个散列函数，第一个函数用于计算探查序列的起始值h(key)，第二个函数用于计算步长，因此双散列法可以写为(h1(key) + i * h2(key)) mod M，i在0到M-1之间
  - 缺点：当删除元素的时候不能真正的删除元素，而是应当将相应位置的标记置为false，否则会影响后续的元素搜索
- 拉链法，Java中hashmap的实现，给hash冲突的元素维护一条链表
- 再哈希法，产生冲突的时候使用另一个hash函数计算，直到不在发生冲突为止
- 建立公共溢出区，建立一个公共溢出区域，把冲突的地方都放在这个地方

