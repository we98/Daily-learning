## 数据结构常见问题
#### 1、几种常见的hash函数
- 除留余数法
  - h(key) = key mod M，其中M是散列表的大小，选择不超过M的素数P，另函数为h(key) = key mod P，会收到比较好的效果
- 平方取中法
  - 首先将key平方，然后取key平方的中间部分作为散列值，中间部分的长度取决于M的大小
  - 假设计算机字长W位，M是散列表长，且当取k时，是的2^k恰好小于等于M，则先对key平方，得到一个W位的值，再将这个值无符号右移W-k位，获得一个0-M-1之前的数字
- 折叠法
  - 假设key = 123 203 241 112 20，且散列地址取三位，则将key划分为5段
  - 移位法：计算123 + 203 + 241 + 112 + 20 = 699，高位舍弃
  - 分界法：计算123 + 302 + 241 + 211 + 20 = 897，高位舍弃
#### 2、解决hash冲突的几种方式
- 开放定址法，和拉链法不同，数据元素都是存到表中的，插入关键字值为key的新元素的方法是：从h(key)开始，依次按照某种规定的次序在表中探查允许插入新元素的空位置，此时地址h(key)被称为基位置，此时探查序列形如：h(key) (h(key) + p(1)) mod M, ......, (h(key) + p(i)) mod M, ......，当发现当前探查位置已经被占据，则探查下一个位置，如果未被占用，则当前元素将其占用
  - 探查序列有以下几个规则/方式：
    - 线性探查法，直接查找下一个元素，当查找到M-1时，另索引为0，从头开始查找，直至h(key)，说明hash表已满
    - 二次探查法，线性探查法有一个缺点，它容易使得许多元素在散列表中连成一片，降低搜索效率，这种现象称为基本聚集。为了解决基本聚集问题，二次探查法提出的策略是h(key)  h(key)+1^2  h(key)-1^2  h(key)+2^2  h(key)-2^2  ......  h(key)+i^2  h(key)-i^2  ......  这样可以消除基本聚集
    - 双散列法，由于对于同一个元素有着相同的探查序列，二次探查法会产生一个问题叫做二级聚集问题。为了解决这个问题，提出了双散列法。思想是准备两个散列函数，第一个函数用于计算探查序列的起始值h(key)，第二个函数用于计算步长，因此双散列法可以写为(h1(key) + i * h2(key)) mod M，i在0到M-1之间
  - 缺点：当删除元素的时候不能真正的删除元素，而是应当将相应位置的标记置为false，否则会影响后续的元素搜索
- 拉链法，Java中hashmap的实现，给hash冲突的元素维护一条链表
- 再哈希法，产生冲突的时候使用另一个hash函数计算，直到不在发生冲突为止
- 建立公共溢出区，建立一个公共溢出区域，把冲突的地方都放在这个地方

#### 3、2-3树

链接：<https://blog.csdn.net/yang_yulei/article/details/26066409>

可用于帮助理解红黑树的构建过程，只不过文章内容稍有瑕疵，可以去看看评论

红链接并不一定是左链接，右链接也是可以的，所以严格意义上来说作者介绍的是左倾红黑树。因为红黑树等同于2-3-4树，而并不是等同于2-3树

#### 4、红黑树

相比于一般的二叉搜索树和平衡搜索树，为了保证搜索的高效以及减小自平衡产生的代价，一棵红黑树必须保证以下规则，有了以下几个规则的束缚，红黑树可以保证自平衡的同时满足最长路径不超过最短路径的2倍：

- 节点是红色或黑色

- 根节点是黑色
- 每个叶子节点都是黑色的空节点
- 每个红色节点的两个子节点都是黑色的（红色节点不能连续）
- 从任意节点到其每个叶子的所有路径都包含相同的黑色节点

> 为什么这几条性质可以完全保证最长路径不会超过最短路径的2倍？
>
> 假设一个极端的情况，树上的节点全部是黑色的，因为每条从根到叶的路径上要求黑色节点数量相同，那么红黑树变为平衡二叉树。在满足第五条规则的情况下，向树中插入红色节点时，假设从根到叶的节点数量为n，那么最多可以插入n - 1个红色节点，因为红色节点不能连续，所以就保证了最长路径不会超过最短路径的2倍

下图是一个典型的红黑树：

![1566225117327](pictures\红黑树.png)

当进行节点插入时，默认插入节点为红色节点，然后再通过变色+旋转进行平衡操作。

参考链接：<https://blog.csdn.net/tanrui519521/article/details/80980135>

#### 5、海量处理题目

给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？

> 可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。

##### 分治/hash映射

遍历文件a，对每个url进行提取，通过给定的hash函数将其映射到1000个小文件其中之一，也如此遍历文件b，这样处理后，所有相同的url肯定在相同序号的对应ab系列小文件里，通过将小文件进行一一比对即可。