## 五层网络模型

- 应用层
- 传输层
- 网络层
- 数据链路层
- 物理层

## 关于Http

### http各个版本异同

#### http1.0和http1.1

- 长连接，http1.0不使用长连接，而http1.1默认使用长连接
- 节约带宽，http1.1支持只发送请求头（header，不带有任何body信息）信息，如果服务器收到请求头并认为客户端有权限请求，就返回100，否则返回401，当客户端收到401时，就不用将body信息发送给服务器了，可以节约带宽
- host域，在http1.0中认为一个物理服务
- 器绑定一个唯一的ip地址，因此，在请求头中，没有传递主机名（hostname），但是随着发展，在一台物理服务器上可以存在多个虚拟主机，并且共享同一个ip地址，因此，需要host这个请求行来指定虚拟主机

#### http1.1和http2.0

- 多路复用，http1.1版本在同一个长连接上可以传递多个请求，但是这些请求是串行执行的，而http2.0中，这些请求可以在同一个连接中并行执行。一个request对应一个id，这样的一个连接之上可以有多个request，接收方可以根据request的id，将request归属到不同的服务端请求中
- 数据压缩，http1.1不支持header数据的压缩，而http2.0可以压缩header数据
- 服务端推送，这个特别适合于请求静态资源，比如在http1.1中的请求方式中，客户端收到网页数据后会得到style.css的地址，这时会重新请求，而有了服务器推送，会直接在当次请求中就发送回客户端，客户端得到style.css的地址之后，不需要去访问网络，直接从缓存中拿

##### 参考：<https://www.cnblogs.com/zhangyfr/p/8662673.html>

### http中不同方法的区别

#### put和post区别

- 幂等性：如果一个方法执行多次，产生的效果是一样的，则称方法具有幂等性

- put和post都有更改指定URI资源的语义，但是在定义方面有不同之处，put被定义为幂等的，而post被定义为非幂登的，也就是说：
  - put：如果两个请求相同的话，后一个请求会覆盖前一个请求，所以put用来修改或更新资源
  - post：后一个请求不会把前一个请求覆盖掉，所以post用来增加或创建资源

#### get和post的区别

- get的参数通过URL传递，post的参数放在request body中
- get的参数会被保留在浏览器的历史记录中，而post不会保留
- get的参数如果存在非ascii字符，会在请求之前进行转码，而post不需要，因为保存在request body中，通过MIME指明类型即可传递非ascii字符和其他二进制数据
- get请求产生一个tcp数据包，post产生两个tcp数据包。对于get方式的请求，浏览器会把header和data一并发送出去，服务器响应200；而对于post，浏览器先发送header，服务器响应100 continue，浏览器再次发送data，服务器响应200返回数据。在网络环境好的情况下，一次包和两次包的时间差别可以无视，但是在网络环境差的情况下，两次包的tcp在验证数据包的完整性时，有着非常大的优点

## 关于Https

### Https解决的问题

http的不足之处：

- 通信内容使用明文——内容可能被窃听
- 不验证通信方的身份——可能遭遇伪装
- 无法验证报文的完整性——报文有可能已遭篡改

#### 解决内容为明文问题——加密

- 密钥解密
  - 使用公开的加密算法
  - 密钥是保密的
  - 使用密钥进行加密和解密
  - 任何人只要得到了关键密钥，就能进行解密，关键密钥如果泄漏，加密就失去了意义
- 密钥解密可分为对称加密和非对称加密
  - 对称加密，加密和解密双方使用同一个密钥，这种方式相较于非对称加密效率较高，但是，由于网络本身就是不安全的，使用网络来传输密钥无法保证不被截取。当然可以不通过网络来发送，比如通过U盘，但是这不能解决网络请求
  - 非对称加密，分为公钥和私钥，公钥可以随意发布，私钥只能自己保存。比如发送者得到接收者的公钥之后，通过公钥加密，只有接收者才能进行解密
- 对称加密和非对称机密的区别
  - 在ssl握手时，使用了非对称加密，而在ssl连接建立后，则使用对称加密
  - 对称加密效率较高

#### 解决报文完整性问题——数字签名

数字签名是用来保证数据完整性的技术，它可以证明数据来自谁，数据是否被篡改过，如在http报文发送过程中，攻击者可以在通信链路（如运营商的路由器）上拦截http请求，并在报文段中插入js或dom节点加入广告（这是常见的流量劫持的手段）

数字签名是附加在数据上的一段特殊的加密过的校验码，它有以下两个好处：

- 数字签名可以证明作者是谁，数字签名是由作者知道的私钥生成的校验码，因此这些校验码就像是作者本人签名一样
- 可以防止数据被篡改，如果被篡改，那么校验码将不匹配

数字签名校验的流程：

- 节点A为将要发送的报文生成摘要（如md5）
- 节点A用自己的私钥对摘要进行签名函数生成数字签名
- 节点A把数字签名附加在要发送的报文段之后，然后把报文段和签名一块发送给B
- 节点B收到报文后，取出数字签名部分，用公钥对签名执行反签名函数得到摘要
- 节点B对报文段部分生成摘要（如md5）
- 节点B对上述两个摘要进行比对，如果相等，则认为报文未被篡改

#### 解决通信双方可能被伪装的问题——认证

有了数字证书就可以验证数据的来源和完整性了，但是仅有数字签名还是有漏洞，假如在握手阶段服务器向客户端发送公钥被攻击者截取，而攻击者将服务器发送给客户端的公钥修改为自己的公钥，那么，之后攻击者可以用自己的私钥给客户端发送数据

为了保证公钥的真实性，引入了数字证书这一手段

数字证书，有点像身份证，是权威机构给某服务器颁发的证书，当客户端和服务器进行ssl握手时，服务器不向客户端直接返回公钥，而是返回一个数字证书，数字证书中包含了使用权威机构私钥加密的公钥和权威机构私钥生成的数字签名

那么，客户端在收到证书之后，如何解密被权威机构私钥加密的公钥呢？其实，在客户端的浏览器和操作系统中，都保存着权威机构的公钥（权威机构和浏览器有合作），这样，客户端就可以解密证书中的公钥

那么，攻击者可以修改这个数字证书吗？答案是不能，因为数字证书中包含着权威机构的数字签名，一旦攻击者修改，则在客户端无法通过报文段的完整性检测

那么，如果攻击者也申请了一个数字证书，那么攻击者是否可以用自己的数字证书替换服务器的数字证书呢？当然可以，只不过这个时候，客户端浏览器访问的网址和得到的数字证书中的网址就不一样了，浏览器会给出警告！

#### https的通信步骤

- 建立ssl连接
  - 客户端向服务器发送ClientHello报文，请求建立ssl连接，其中包含着客户端支持的ssl版本，支持的加密算法，支持的密钥长度
  - 服务端收到ClientHello报文后，向客户端发送ServerHello报文，返回决定采用的ssl版本和决定使用的加密算法
  - 服务器继续发送Certificate报文，即服务器的数字证书，其中包含服务器的公钥
  - 服务器发送ServerHelloDone报文，通知最初阶段的ssl握手协商部分结束
  - 客户端收到以上信息后，发送ClientKeyExchange报文作为响应，该报文已经使用了服务器的公钥加密，其中包含了一个称为Pre-master secret的随机密码串，作为在此之后通信使用的对称加密的密钥
  - 客户端继续发送ChangeCipherSpec报文，告诉服务器，在此之后的通信都会使用Pre-master secret加密
  - 客户端发送Finished报文，该报文包含连接至今全部报文的整体校验值
  - 服务器发送ChangeCipherSpec报文，意义相同
  - 服务器发送Finished报文，意义相同
  - Finished报文交换完毕后，ssl连接建立
- http通信
  - 使用http进行应用层通信，同时使用对称加密传递数据
- 关闭连接
  - 客户端发送 close_notify 报文请求断开连接。之后再发送 TCP FIN 报文来关闭 TCP 通信

#### 参考：

<http://liuduo.me/2018/05/14/https-detail/>

<https://blog.csdn.net/winwill2012/article/details/71774469>

## 关于Tcp

- 关于三次握手四次挥手：<https://blog.csdn.net/qq_38950316/article/details/81087809>   <https://blog.csdn.net/whuslei/article/details/6667471>

## 关于Cookie