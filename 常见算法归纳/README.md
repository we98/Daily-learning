- question1: 在一个从左到右递增，从上到下递增的数组中判断一个数是否存在 。
- question2: 将字符串中的空格替换为"%20" 。
- question3: 将单向链表逆序返回一个ArrayList。
- question4: 字符串转数字 。
- question5: 各种基本排序，冒泡排序、选择排序、插入排序等O(N2)复杂度的算法以及使用对数器来验证自己的算法是否正确等 。冒泡、插入稳定，选择不稳定。	
- question6: 归并排序（算法复杂度O(N*logN)），空间复杂度为O(N)以及由归并排序涉及的经典问题：数组的小和、输出数组所有的逆序对。
- question7: 将数组分为两部分的partition思想，以及用于荷兰国旗问题的将数组分为三部分的思想，可以用于快排（O(N*logN)），空间复杂度为O(logN)，快排是三个O(N*logN)最常用的和效率最高的快排，可以这样理解：快排代码简洁，在算法复杂度一样的情形下常数项比较小，因此具有优势，归并排序在实际生产过程经过大量测试输给了快排，主要原因是大量时间花在了数组拷贝上，而快排只需在原数组进行数据交换即可。同时利用partition的思想可以解决lintcode上求数组中第K大元素的问题：[https://www.lintcode.com/problem/kth-largest-element/description](https://www.lintcode.com/problem/kth-largest-element/description)。
> QuickSort类里面记录了常见的二路快排和三路快排算法思想
- question8: 堆排序，堆是一个非常重要的数据结构，所有的贪心算法离不开堆，所以必须要掌握，向上调整用于建堆过程，向下调整用于某个位置的值发生改变后重新调整堆。总结起来，归并稳定，快排、堆排不稳定。
> 关于工程中的综合排序算法：如果数组中装的是基本数据类型，那么直接使用快速排序，因为无关稳定性。如果装的是引用类型，数据量大的时候会使用堆排序，这是基于稳定性出发的，当数据量较小的时候，如小于60，则就会切换为插入排序，首先因为插入稳定，再者，在数据量很小的时候，插入排序的算法复杂度劣势体现不出来，因为常数项较小。
- question10: 用固定长度的数组实现固定长度的栈和队列，虽然基础，但是面试容易考到。
- question11: 最小栈，通过两个栈实现，两个栈同步push和同步pop。
- question12: 用两个队列实现栈，用两个栈实现队列，注意面试的时候如果只能由栈解决的问题却被问到用队列解决，便有可能使用这种方式。
- question13: 猫狗队列问题。
- question14: 转圈打印矩阵,矩阵的转置（旋转90度），利用的思想是大局观的思想，一圈一圈的处理。
- question15: 以斜着的“之”字形打印二维数组，也利用了宏观的思想，一条线一条线的处理。
- question16: 判断链表是否属于回文结构，时间复杂度O(N)（事实上，关于链表的问题时间复杂度都是这样，主要区别在于空间复杂度），使用几种空间复杂度来解决这个问题，笔试的时候推荐使用高的空间复杂度，因为只要过了就行，而面试时最好使用低的空间复杂度。
- question17: 链表的荷兰国旗问题（对空间复杂度不做要求），以及进阶版（时间复杂度为O(N)，空间复杂度为O(1)，且排序之后要稳定）。
- question18: 两个单链表相交的一系列问题。①判断一个单链表有环或者无环，如果无环，返回null，如果有环，返回入环节点。②得到两个无环链表的第一个相交的节点，如果不相交，返回null。③得到两个有环链表的第一个相交的节点，如果不相交，返回null。这道题难度比较大，且用到了一些数学证明。
- question19: 二叉树的先序中序后序遍历递归和非递归实现，以及使用0(1)空间的Morris遍历，参考：<https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html>
- question20: 打印二叉树的函数。
- question21: 给定任何一个二叉树中的节点（节点中加入parent指针），找到其前驱节点和后继节点，前驱和后继分别是中序遍历中在这个node前和后的节点。
- question22: 二叉树的序列化和反序列化。lintcode地址：[https://www.lintcode.com/problem/serialize-and-deserialize-binary-tree/description](https://www.lintcode.com/problem/serialize-and-deserialize-binary-tree/description)
- question23: 判断二叉树是否平衡以及求二叉树的高度。通过这道题整理出二叉树递归方法通用思路：①针对一个节点，需要得到左子树的什么，需要得到右子树的什么；②根据第一步的判断，整理和归纳出递归函数的返回类型；③实际编码中，应该先收集左子树的信息，再收集右子树的信息，而递归函数本身要做最重要的一个步骤，那就是根据左子树和右子树的返回信息归纳出自己的返回信息并返回。
- question24: 判断一棵二叉树是否为搜索二叉树，判断是否为完全二叉树。
- question25: 得到一个完全二叉树的节点个数，空间复杂度低于O(N)，其实这个算法的复杂度是O((logN)2)。
- question26: 二叉树折纸问题。
- question27: 贪心问题一：字符串数组连接得到的最小字典序的字符串。
- question28: 贪心问题二：一块金条切成两半，是需要花费和长度数值一样的铜板的。比如：长度为20的 金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金 条，怎么分最省铜板？例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为10+20+30=60. 金条要分成10,20,30三个部分。 如果， 先把长度60的金条分成10和50，花费60 再把长度50的金条分成20和30，花费50 一共花费110铜板。但是如果， 先把长度60的金条分成30和30，花费60 再把长度30金条分成10和20，花费30 一共花费90铜板。输入一个数组，返回分割的最小代价。
- question29: 贪心问题三：存在一个项目列表，该列表中存在一个数组costs，代表投资某个项目需要的本钱；存在一个数组profits，代表投资该项目后净赚的钱。给定本金w，求在只能最多投资k个项目的情况下，将收益达到最大。
- question30: 几个经典递归问题。①汉诺塔问题②打印字符数组所有的子序列③打印字符串的全排列。
- question31: 暴力递归与动态规划一：从二维数组左上角移动到右下角，求最小路径和，假设数组里面只有正数。
- question32: 暴力递归与动态规划二：给定一个数组和一个数sum，判断数组中是否存在几个数相加得到sum，假设数组中只有正数。
- question33: 暴力递归与动态规划三：01背包问题。
- question34: 构造图的一般化结构，此结构可用于解决多个问题。
- question35: 图的深度优先遍历和宽度优先遍历。
- question36: 图的拓扑排序，要求是有向图，且存在入度为0的顶点，不存在环路，意义是为了存在依赖事物发生的先后次序。
- question37: 并查集的使用，以及经典的算法问题：朋友圈算法。
- question38: 图的最小生成树算法：①Kruskal算法，使用并查集，思想是从边开始考察，将边按照权值排序后，依次选出权重较小的边，如果该边对应的两个顶点属于不同的树，则合并，注意该算法过程中，所有的节点被分成森林，最后将森林逐一合并因此，该算法适用于边较少的图，也就是较稀疏的图；②Prim算法，该算法的思想是逐一取点，每取一个点，与该点相连的所有边就会被加到优先权队列中，通过优先权队列最小的边去寻找下一个最近的点，寻找之后继续解锁边加入到优先权队列中去，注意如果通过最小边到达的新顶点已经加入到生成树中，则需要重新从最小堆中寻找最短的边去找新的顶点。该算法适合于顶点较少，边较多的情况，即稠密图。
- question39: 图的最短路径算法，Dijkstra算法。
- question40: 给定原文本和模式文本，求出原文本中符合模式文本的最大左匹配。
- question41: leetcode题目：[https://leetcode.com/problems/backspace-string-compare](https://leetcode.com/problems/backspace-string-compare)，"##ab#c"与"ac"相等，其中#代表删除。
- question42: leetcode题目：[https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)，通过二分查找得出和目标值相等的所有数的下标范围，不存在相等则返回[-1, -1]。
- question43: leetcode题目：[https://leetcode.com/problems/multiply-strings](https://leetcode.com/problems/multiply-strings)，实现字符串的乘法，思想是用一个字符与另一个字符串相乘，最后再加起来，注意进位要正确。
- question44：常见二分搜索代码总结。①找到恰好相等的数；②找到第一个大于等于目标值的数；③找到第一个大于目标值的数；④找到最后一个小于等于目标值的数；⑤找到最后一个小于目标值的数。相关题目：[https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
- question45：进制转换问题，一路求模做除法
- question46: 使用O(nlogn)的方式对链表进行排序，要求占用常量空间，可以使用merge方式和partition方式，但一定要注意细节，leetcode148